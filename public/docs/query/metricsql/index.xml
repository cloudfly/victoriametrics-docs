<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MetricQL on 中文手册(WIP)</title>
    <link>http://localhost:1313/docs/query/metricsql/</link>
    <description>Recent content in MetricQL on 中文手册(WIP)</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="http://localhost:1313/docs/query/metricsql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基本用法</title>
      <link>http://localhost:1313/docs/query/metricsql/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/query/metricsql/basic/</guid>
      <description>&lt;h2 id=&#34;过滤器&#34;&gt;过滤器&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://www.yuque.com/icloudfly/xs51ky/onpelg16wg77xin6&#34;&gt;数据查询&lt;/a&gt;部分我们已经用 MetricsQL 获取了指标 &lt;code&gt;foo_bar&lt;/code&gt; 的数据。只需在查询中写入指标名称，就能轻松完成：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;foo_bar&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个简单的指标名称会得到拥有不同 label 组合的多个 Timeseries 返回响应值。比如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;requests_total{path=&amp;#34;/&amp;#34;, code=&amp;#34;200&amp;#34;} &#xA;requests_total{path=&amp;#34;/&amp;#34;, code=&amp;#34;403&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要选择具有特定 Label 的 Timeseries，需要在花括号中指定匹配 Label 的过滤器：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;requests_total{code=&amp;#34;200&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的查询语句返回所有名字是 &lt;code&gt;requests_total &lt;/code&gt;并且 Label 带有&lt;code&gt;code=&amp;quot;200&amp;quot;&lt;/code&gt;的所有&lt;code&gt;Timeseries&lt;/code&gt;。我们用&lt;code&gt;=&lt;/code&gt;运算符来匹配 Label 值。对于反匹配使用&lt;code&gt;!=&lt;/code&gt;运算符。过滤器也通过&lt;code&gt;=~&lt;/code&gt;实现正则匹配，用&lt;code&gt;!~&lt;/code&gt;实现正则反匹配。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;requests_total{code=~&amp;#34;2.*&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;过滤器也可以被组合使用：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;requests_total{code=~&amp;#34;200&amp;#34;, path=&amp;#34;/home&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的查询返回所有名字是&lt;code&gt;request_total&lt;/code&gt;，同时带有 &lt;code&gt;code=&amp;quot;200&amp;quot;&lt;/code&gt; 和 &lt;code&gt;path=&amp;quot;/home&amp;quot;&lt;/code&gt; Label 的所有 Timeseries。&lt;/p&gt;&#xA;&lt;h3 id=&#34;使用名字过滤&#34;&gt;使用名字过滤&lt;/h3&gt;&#xA;&lt;p&gt;有时我们可能需要同时返回多个监控指标。就如同&lt;a href=&#34;https://www.yuque.com/icloudfly/xs51ky/usya0z8utkby2rog&#34;&gt;数据模型&lt;/a&gt;中提到的，Metric 名称本质上也是一个普通的 Label 的值，其 Label 名是&lt;code&gt;__name__&lt;/code&gt;。所以可以通过对 Metric 名使用正则的方式，来过滤出多个指标名的数据：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;{__name__=~&amp;#34;requests_(error|success)_total&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的查询语句会返回 2 个 Metric 的 Timeseries：&lt;code&gt;requests_error_total&lt;/code&gt; 和&lt;code&gt;requests_success_total&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;利用-or-使用多个过滤器&#34;&gt;利用 or 使用多个过滤器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.victoriametrics.com/MetricsQL.html&#34;&gt;MetricsQL&lt;/a&gt; 支持查询至少满足多个过滤器中的一个方式来获取 Timeseries。这些过滤器必须在花括号内使用 &lt;code&gt;or&lt;/code&gt; 分割。 比如，下面的查询代表查询 Label 满足 &lt;code&gt;{job=&amp;quot;app1&amp;quot;,env=&amp;quot;prod&amp;quot;}&lt;/code&gt; 或 &lt;code&gt;{job=&amp;quot;app2&amp;quot;,env=&amp;quot;dev&amp;quot;}&lt;/code&gt; 的 Timeseries：&lt;/p&gt;</description>
    </item>
    <item>
      <title>PromQL 新手入门</title>
      <link>http://localhost:1313/docs/query/metricsql/promql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/query/metricsql/promql/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/querying/basics/&#34;&gt;PromQL&lt;/a&gt; 是 &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt; 系统的查询语言。它是为绘图、告警或派生 Timeseries（通过 &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/&#34;&gt;recording rules&lt;/a&gt;） 场景而设计的强大且简单的语言。PromQL 是从零开始设计的，与其他在时间序列数据库中使用的查询语言（比如 &lt;a href=&#34;https://www.timescale.com/&#34;&gt;TimescaleDB 的 SQ&lt;/a&gt;L，&lt;a href=&#34;https://docs.influxdata.com/influxdb/v1.7/query_language/&#34;&gt;InfluxQL&lt;/a&gt; 或者 &lt;a href=&#34;https://github.com/influxdata/flux&#34;&gt;Flux&lt;/a&gt;）没有任何共同之处。&lt;/p&gt;&#xA;&lt;p&gt;这样做可以为典型的 TSDB 查询创建一个清晰的语言。但是它也有代价 - 初学者通常需要花费几个小时阅读官方的&lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/querying/basics/&#34;&gt;PromQL文档&lt;/a&gt;，才能理解其工作原理。让我们简化和缩短 PromQL 的学习曲线。&lt;/p&gt;&#xA;&lt;h2 id=&#34;查询一个-timeseries&#34;&gt;查询一个 Timeseries&lt;/h2&gt;&#xA;&lt;p&gt;选择使用 PromQL 查询 Timeseries 就像在查询中写入一个时间序列名称一样简单。例如，下面的查询将返回所有名称为&lt;code&gt;node_network_receive_bytes_total&lt;/code&gt;的 timeseries：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;node_network_receive_bytes_total&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个名称源自于&lt;a href=&#34;https://github.com/prometheus/node_exporter&#34;&gt;node_exporter指标&lt;/a&gt;，它包含了在各种网络接口上接收的字节数。这样一个简单的查询可能会返回具有相同名称但带有不同 Label Set 的多个 Timeseries。例如，上面的查询可能会返回以下 &lt;code&gt;device&lt;/code&gt; Label 等于&lt;code&gt;eth0&lt;/code&gt;、&lt;code&gt;eth1&lt;/code&gt;和&lt;code&gt;eth2&lt;/code&gt;的 Timeseries：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;node_network_receive_bytes_total{device=&amp;#34;eth0&amp;#34;}&#xA;node_network_receive_bytes_total{device=&amp;#34;eth1&amp;#34;}&#xA;node_network_receive_bytes_total{device=&amp;#34;eth2&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不通的Label被放在了花括号中：&lt;code&gt;{device=&amp;quot;eth0&amp;quot;}&lt;/code&gt;, &lt;code&gt;{device=&amp;quot;eth1&amp;quot;}&lt;/code&gt;, &lt;code&gt;{device=&amp;quot;eth2&amp;quot;}&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;让我们来看下 TimescaleDB 的 SQL 来达到同样的效果：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plsql&#34; data-lang=&#34;plsql&#34;&gt;SELECT&#xA;  ts.metric_name_plus_tags,&#xA;  r.timestamps,&#xA;  r.values&#xA;FROM (&#xA;  (SELECT&#xA;   time_series_id,&#xA;   array_agg(timestamp ORDER BY timestamp) AS timestamps,&#xA;   array_agg(value ORDER BY timestamp) AS values&#xA;   FROM&#xA;   metrics&#xA;   WHERE&#xA;   time_series_id IN (&#xA;     SELECT id FROM time_series&#xA;     WHERE metric_name = &amp;#39;node_network_receive_bytes_total&amp;#39;&#xA;   )&#xA;   GROUP BY&#xA;   time_series_id&#xA;  )&#xA;) AS r JOIN time_series AS ts ON (r.time_series_id = ts.id)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对比下来是不是觉得很简单。SQL 不得不写得更加复杂，才能与上述的PromQL查询结果相媲美。因为 SQL 不会自带时间范围和降采样机制，但这些都会被 &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/querying/api/#range-queries&#34;&gt;PromQL 的 /query_range&lt;/a&gt; 接口 使用&lt;code&gt;start&lt;/code&gt;，&lt;code&gt;end&lt;/code&gt;和&lt;code&gt;step&lt;/code&gt;参数自动完成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>对比PromQL</title>
      <link>http://localhost:1313/docs/query/metricsql/promql-diff/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/query/metricsql/promql-diff/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://docs.victoriametrics.com/MetricsQL.html&#34;&gt;MetricsQL&lt;/a&gt; is a query language inspired by &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/querying/basics/&#34;&gt;PromQL&lt;/a&gt;. It is used as a primary query language in &lt;a href=&#34;https://github.com/victoriaMetrics/victoriaMetrics&#34;&gt;VictoriaMetrics&lt;/a&gt;, time series database and monitoring solution. MetricsQL claims to be backward-compatible with PromQL, so Grafana dashboards backed by a Prometheus datasource should work the same after switching from Prometheus to VictoriaMetrics.&lt;/p&gt;&#xA;&lt;p&gt;However, VictoriaMetrics is not 100% compatible with PromQL and never will be. Please read on and we will discuss why that is.&lt;/p&gt;&#xA;&lt;p&gt;For a long time, there was no way to measure compatibility with PromQL. There was not even a fully defined &lt;a href=&#34;https://promlabs.com/blog/2020/08/06/comparing-promql-correctness-across-vendors#what-is-correct-in-the-absence-of-a-specification&#34;&gt;PromQL specification&lt;/a&gt;. But, some time ago, the &lt;a href=&#34;https://prometheus.io/blog/2021/05/03/introducing-prometheus-conformance-program/&#34;&gt;Prometheus Conformance Program&lt;/a&gt; was announced with the aim to certify software with a mark of compatibility with Prometheus — “Upon reaching 100%, the mark will be granted&amp;quot;. The open-source tool, &lt;a href=&#34;https://github.com/prometheus/compliance&#34;&gt;prometheus/compliance&lt;/a&gt; was created to check for compatibility.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
